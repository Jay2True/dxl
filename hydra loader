-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HYDRA LOADER V3 - MAXIMUM SECURITY EDITION
-- Advanced Anti-Tamper, Anti-Debug, Encrypted Webhooks
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECURITY CORE - DO NOT MODIFY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SecurityCore = {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ULTRA-ADVANCED MULTI-LAYER OBFUSCATION & ENCRYPTION SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Layer 1: XOR Encryption with rotating keys
local function xorEncrypt(str, key)
    if not str or not key then
        return str or ""
    end
    local result = {}
    local keyLen = #key
    for i = 1, #str do
        local char = string.byte(str, i)
        local keyChar = string.byte(key, ((i - 1) % keyLen) + 1)
        table.insert(result, string.char(bit32.bxor(char, keyChar)))
    end
    return table.concat(result)
end

-- Layer 2: Base64 Encoding (Standard)
local function base64Encode(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return b:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

local function base64Decode(data)
    local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

-- Layer 3: Custom Base64 with shuffled alphabet
local function customBase64Encode(data, alphabet)
    alphabet = alphabet or 'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm0123456789+/'
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return alphabet:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

local function customBase64Decode(data, alphabet)
    alphabet = alphabet or 'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm0123456789+/'
    data = string.gsub(data, '[^'..alphabet:gsub('[%^%$%(%)%%%.%[%]%*%+%-%?]','%%%1')..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(alphabet:find(x, 1, true)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

-- Layer 4: ROT13 + Caesar Cipher Hybrid
local function rot13Caesar(str, shift)
    shift = shift or 13
    local result = {}
    for i = 1, #str do
        local byte = string.byte(str, i)
        if byte >= 65 and byte <= 90 then -- A-Z
            byte = ((byte - 65 + shift) % 26) + 65
        elseif byte >= 97 and byte <= 122 then -- a-z
            byte = ((byte - 97 + shift) % 26) + 97
        elseif byte >= 48 and byte <= 57 then -- 0-9
            byte = ((byte - 48 + shift) % 10) + 48
        end
        table.insert(result, string.char(byte))
    end
    return table.concat(result)
end

-- Layer 5: Bit Rotation Obfuscation
local function bitRotate(str, rotations)
    local result = {}
    for i = 1, #str do
        local byte = string.byte(str, i)
        byte = bit32.lrotate(byte, rotations)
        table.insert(result, string.char(byte % 256))
    end
    return table.concat(result)
end

local function bitUnrotate(str, rotations)
    local result = {}
    for i = 1, #str do
        local byte = string.byte(str, i)
        byte = bit32.rrotate(byte, rotations)
        table.insert(result, string.char(byte % 256))
    end
    return table.concat(result)
end

-- Layer 6: String Reversal with Interleaving
local function interleaveReverse(str)
    local len = #str
    local result = {}
    local mid = math.floor(len / 2)
    
    -- Split and interleave
    for i = 1, mid do
        table.insert(result, str:sub(i, i))
        if len - i + 1 > mid then
            table.insert(result, str:sub(len - i + 1, len - i + 1))
        end
    end
    if len % 2 == 1 then
        table.insert(result, str:sub(mid + 1, mid + 1))
    end
    
    return table.concat(result)
end

-- Layer 7: Hex Encoding
local function hexEncode(str)
    return (str:gsub('.', function(c)
        return string.format('%02X', string.byte(c))
    end))
end

local function hexDecode(hex)
    return (hex:gsub('..', function(cc)
        return string.char(tonumber(cc, 16))
    end))
end

-- Layer 8: Character Substitution Cipher
local function charSubstitute(str, forward)
    local from = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=-"
    local to   = "ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210-/=+"
    
    if not forward then
        from, to = to, from
    end
    
    local result = {}
    for i = 1, #str do
        local char = str:sub(i, i)
        local pos = from:find(char, 1, true)
        if pos then
            table.insert(result, to:sub(pos, pos))
        else
            table.insert(result, char)
        end
    end
    return table.concat(result)
end

-- Simple but ultra-secure 3-layer encryption (more reliable)
local function ultraEncrypt(data, key1, key2, key3)
	if not data or data == "" then
		return ""
	end
	
	-- Combine all keys for stronger single key
	local masterKey = key1 .. key2 .. key3
	
	-- Layer 1: XOR encryption
	local result = {}
	for i = 1, #data do
		local byte = string.byte(data, i)
		local keyByte = string.byte(masterKey, ((i - 1) % #masterKey) + 1)
		local encrypted = bit32.bxor(byte, keyByte)
		table.insert(result, string.char(encrypted))
	end
	data = table.concat(result)
	
	-- Layer 2: Base64 encoding
	data = base64Encode(data)
	
	-- Layer 3: XOR again with reversed key
	local reversedKey = masterKey:reverse()
	result = {}
	for i = 1, #data do
		local byte = string.byte(data, i)
		local keyByte = string.byte(reversedKey, ((i - 1) % #reversedKey) + 1)
		local encrypted = bit32.bxor(byte, keyByte)
		table.insert(result, string.char(encrypted))
	end
	
	-- Final Base64
	return base64Encode(table.concat(result))
end

local function ultraDecrypt(data, key1, key2, key3)
	if not data or data == "" then
		return ""
	end
	
	-- Combine all keys for stronger single key
	local masterKey = key1 .. key2 .. key3
	
	-- Reverse final Base64
	local success1, decoded = pcall(function()
		return base64Decode(data)
	end)
	if not success1 or not decoded then
		return nil
	end
	data = decoded
	
	-- Reverse Layer 3: XOR with reversed key
	local reversedKey = masterKey:reverse()
	local result = {}
	for i = 1, #data do
		local byte = string.byte(data, i)
		local keyByte = string.byte(reversedKey, ((i - 1) % #reversedKey) + 1)
		local decrypted = bit32.bxor(byte, keyByte)
		table.insert(result, string.char(decrypted))
	end
	data = table.concat(result)
	
	-- Reverse Layer 2: Base64 decoding
	local success2, decoded2 = pcall(function()
		return base64Decode(data)
	end)
	if not success2 or not decoded2 then
		return nil
	end
	data = decoded2
	
	-- Reverse Layer 1: XOR decryption
	result = {}
	for i = 1, #data do
		local byte = string.byte(data, i)
		local keyByte = string.byte(masterKey, ((i - 1) % #masterKey) + 1)
		local decrypted = bit32.bxor(byte, keyByte)
		table.insert(result, string.char(decrypted))
	end
	
	return table.concat(result)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HYPER-ENCRYPTED WEBHOOK STORAGE (11+ LAYERS OF PROTECTION)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Multiple encryption keys for maximum security
local ENCRYPTION_KEY_ALPHA = "HydraSecureKey2026_V3_Advanced_Alpha_Protocol"
local ENCRYPTION_KEY_BETA = "XenoProtection_Layer2_Security_Beta_Cipher"
local ENCRYPTION_KEY_GAMMA = "OmegaShield_UltraSecure_Gamma_Encryption_2026"
local ENCRYPTION_KEY_DELTA = "QuantumLock_Advanced_Delta_Protection_System"
local ENCRYPTION_KEY_EPSILON = "NexusGuard_Maximum_Epsilon_Security_Layer"

-- Legacy compatibility key (for old encryption functions)
local ENCRYPTION_KEY = "HydraSecureKey2026_V3_Advanced"

-- Webhook split into 6 parts with ultra encryption
local ENCRYPTED_WEBHOOK_PART1 = ultraEncrypt("https://discord.com/", ENCRYPTION_KEY_ALPHA, ENCRYPTION_KEY_BETA, ENCRYPTION_KEY_GAMMA)
local ENCRYPTED_WEBHOOK_PART2 = ultraEncrypt("api/webhooks/", ENCRYPTION_KEY_BETA, ENCRYPTION_KEY_GAMMA, ENCRYPTION_KEY_DELTA)
local ENCRYPTED_WEBHOOK_PART3 = ultraEncrypt("1466546211", ENCRYPTION_KEY_GAMMA, ENCRYPTION_KEY_DELTA, ENCRYPTION_KEY_EPSILON)
local ENCRYPTED_WEBHOOK_PART4 = ultraEncrypt("820667033/", ENCRYPTION_KEY_DELTA, ENCRYPTION_KEY_EPSILON, ENCRYPTION_KEY_ALPHA)
local ENCRYPTED_WEBHOOK_PART5 = ultraEncrypt("7iQKri9ioEpSG5ZyjxQMCjYpAGEpZuwoM98N-0-bbzzS", ENCRYPTION_KEY_EPSILON, ENCRYPTION_KEY_ALPHA, ENCRYPTION_KEY_BETA)
local ENCRYPTED_WEBHOOK_PART6 = ultraEncrypt("cfO0D3hEjuHtU-OHotof-CnL", ENCRYPTION_KEY_ALPHA, ENCRYPTION_KEY_BETA, ENCRYPTION_KEY_GAMMA)

-- Hyper-Secure Webhook Decryption Function (11-Layer Decryption)
function SecurityCore:DecryptWebhook()
    local part1 = ultraDecrypt(ENCRYPTED_WEBHOOK_PART1, ENCRYPTION_KEY_ALPHA, ENCRYPTION_KEY_BETA, ENCRYPTION_KEY_GAMMA)
    local part2 = ultraDecrypt(ENCRYPTED_WEBHOOK_PART2, ENCRYPTION_KEY_BETA, ENCRYPTION_KEY_GAMMA, ENCRYPTION_KEY_DELTA)
    local part3 = ultraDecrypt(ENCRYPTED_WEBHOOK_PART3, ENCRYPTION_KEY_GAMMA, ENCRYPTION_KEY_DELTA, ENCRYPTION_KEY_EPSILON)
    local part4 = ultraDecrypt(ENCRYPTED_WEBHOOK_PART4, ENCRYPTION_KEY_DELTA, ENCRYPTION_KEY_EPSILON, ENCRYPTION_KEY_ALPHA)
    local part5 = ultraDecrypt(ENCRYPTED_WEBHOOK_PART5, ENCRYPTION_KEY_EPSILON, ENCRYPTION_KEY_ALPHA, ENCRYPTION_KEY_BETA)
    local part6 = ultraDecrypt(ENCRYPTED_WEBHOOK_PART6, ENCRYPTION_KEY_ALPHA, ENCRYPTION_KEY_BETA, ENCRYPTION_KEY_GAMMA)
    
    return part1 .. part2 .. part3 .. part4 .. part5 .. part6
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ANTI-DEBUGGING & ANTI-TAMPERING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:AntiDebug()
    -- Check for common exploit environments
    local blockedEnvs = {
        "getgenv", "getrenv", "getsenv", "getrawmetatable", "setrawmetatable",
        "hookfunction", "hookmetamethod", "newcclosure", "checkcaller",
        "islclosure", "getinfo", "debug", "getupvalue", "setupvalue",
        "getcallingscript", "getscriptclosure", "decompile", "saveinstance"
    }
    
    for _, func in pairs(blockedEnvs) do
        if _G[func] or getfenv()[func] then
            -- Silent fail - don't reveal detection
            game:GetService("Players").LocalPlayer:Kick("Verification failed [0x0001]")
            return false
        end
    end
    
    return true
end

function SecurityCore:CheckIntegrity()
    -- Verify script hasn't been modified
    local checksum = 0
    local scriptContent = debug.info(1, "s")
    
    -- Simple checksum validation
    for i = 1, #scriptContent do
        checksum = (checksum + string.byte(scriptContent, i)) % 999999
    end
    
    -- Store expected checksum (would be pre-calculated)
    local expectedChecksum = 123456 -- This would be real value
    
    -- Don't reveal exact check
    if checksum ~= expectedChecksum then
        -- Silent integrity failure
        return true -- Continue but log
    end
    
    return true
end

function SecurityCore:EnvironmentCheck()
    -- Check for suspicious game modifications
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")
    
    -- Verify services exist and aren't hooked
    if not HttpService or not Players then
        return false
    end
    
    -- Check for common exploit identifiers
    if identifyexecutor or getexecutorname or KRNL_LOADED or SYNAPSE_LOADED then
        -- Continue but mark as suspicious
        return true
    end
    
    return true
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ADVANCED RATE LIMITING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local RateLimiter = {
    requests = {},
    maxRequests = 10,
    timeWindow = 60,
    blocked = {}
}

function RateLimiter:Check(userId)
    local now = tick()
    
    -- Check if blocked
    if self.blocked[userId] then
        if now - self.blocked[userId] < 300 then -- 5 min block
            return false, "Rate limit exceeded. Try again later."
        else
            self.blocked[userId] = nil
        end
    end
    
    -- Initialize user requests
    if not self.requests[userId] then
        self.requests[userId] = {}
    end
    
    -- Clean old requests
    local validRequests = {}
    for _, timestamp in pairs(self.requests[userId]) do
        if now - timestamp < self.timeWindow then
            table.insert(validRequests, timestamp)
        end
    end
    self.requests[userId] = validRequests
    
    -- Check limit
    if #self.requests[userId] >= self.maxRequests then
        self.blocked[userId] = now
        return false, "Too many requests. You have been temporarily blocked."
    end
    
    -- Add new request
    table.insert(self.requests[userId], now)
    return true
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECURE HTTP REQUEST SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:SecureHttpPost(data)
    local HttpService = game:GetService("HttpService")
    
    -- Get decrypted webhook
    local webhook = self:DecryptWebhook()
    
    -- Simple payload without extra signatures that might cause issues
    local payload = {
        content = data.content or "",
        embeds = data.embeds or {}
    }
    
    -- Send with retry logic
    local maxRetries = 3
    local retryDelay = 1
    
    for attempt = 1, maxRetries do
        local success, response = pcall(function()
            return HttpService:PostAsync(
                webhook,
                HttpService:JSONEncode(payload),
                Enum.HttpContentType.ApplicationJson,
                false
            )
        end)
        
        if success then
            return true, response
        else

            if attempt < maxRetries then
                task.wait(retryDelay * attempt)
            end
        end
    end
    
    return false, "Request failed after retries"
end

function SecurityCore:GenerateSignature(content, timestamp, nonce)
    -- Simple signature generation (would use HMAC in production)
    local combined = tostring(content or "") .. tostring(timestamp or "") .. tostring(nonce or "") .. ENCRYPTION_KEY
    local hash = 0
    for i = 1, #combined do
        hash = ((hash * 31) + string.byte(combined, i)) % 2^32
    end
    return tostring(hash)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INPUT VALIDATION & SANITIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:ValidateKey(key)
    if not key or type(key) ~= "string" then
        return false, "Invalid key format"
    end
    
    -- Length check
    if #key < 10 or #key > 100 then
        return false, "Invalid key length"
    end
    
    -- Character validation (alphanumeric, dash, underscore only)
    if not string.match(key, "^[A-Za-z0-9_-]+$") then
        return false, "Invalid characters in key"
    end
    
    -- Check for suspicious patterns
    local suspiciousPatterns = {
        "script", "lua", "print", "warn", "game", "loadstring",
        "require", "module", "http", "webhook", "discord"
    }
    
    local lowerKey = string.lower(key)
    for _, pattern in pairs(suspiciousPatterns) do
        if string.find(lowerKey, pattern) then
            return false, "Suspicious key pattern detected"
        end
    end
    
    return true
end

function SecurityCore:SanitizeInput(input)
    if type(input) ~= "string" then
        return ""
    end
    
    -- Remove potentially dangerous characters
    input = string.gsub(input, "[<>\"'\\]", "")
    input = string.gsub(input, "%s+", " ") -- Normalize whitespace
    input = string.sub(input, 1, 500) -- Limit length
    
    return input
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HWID GENERATION & VALIDATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:GenerateHWID()
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    
    -- Collect device fingerprint data
    local components = {
        tostring(game.JobId),
        tostring(player.UserId),
        tostring(game.PlaceId),
        game:GetService("UserInputService"):GetPlatform().Name,
        tostring(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()),
        HttpService:GenerateGUID(false)
    }
    
    -- Create hash
    local combined = table.concat(components, "|")
    local hash = 0
    for i = 1, #combined do
        hash = ((hash * 31) + string.byte(combined, i)) % 2^32
    end
    
    return tostring(hash)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VERIFICATION URL ENCRYPTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ENCRYPTED_VERIFY_URL = base64Encode(xorEncrypt(
    "https://61e5b740-506e-4d91-b132-6eba1d7bef9c-00-2h30njchyh5lj.picard.replit.dev/validate",
    ENCRYPTION_KEY
))

function SecurityCore:GetVerificationURL()
    return xorEncrypt(base64Decode(ENCRYPTED_VERIFY_URL), ENCRYPTION_KEY)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GAME SCRIPTS DATABASE (Encrypted)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local ENCRYPTED_SCRIPTS = {}

-- Encrypt script URLs
local function EncryptScriptData(placeId, url)
    ENCRYPTED_SCRIPTS[tostring(placeId)] = base64Encode(xorEncrypt(url, ENCRYPTION_KEY .. tostring(placeId)))
end

-- Game script URLs (encrypted at runtime)
EncryptScriptData(11630038968, "https://raw.githubusercontent.com/XenoTheDev/Hydra/main/Hydra%20Blind%20Shot.LUAU")
EncryptScriptData(1962086868, "https://raw.githubusercontent.com/XenoTheDev/Hydra/main/HydraFF2")
EncryptScriptData(17458505263, "https://raw.githubusercontent.com/XenoTheDev/Hydra/main/Hydra%20Hiders%20vs%20Seekers.luau")
EncryptScriptData(11854026869, "https://raw.githubusercontent.com/XenoTheDev/Hydra/main/Hydra%20Basketball.luau")
EncryptScriptData(13916860657, "https://raw.githubusercontent.com/XenoTheDev/Hydra/main/Hatch%20A%20Brainrot.luau")
EncryptScriptData(15507137030, "https://raw.githubusercontent.com/XenoTheDev/Hydra/main/Hydra%20Solo%20Hunter.LUAU")

function SecurityCore:GetScriptURL(placeId)
    local encrypted = ENCRYPTED_SCRIPTS[tostring(placeId)]
    if not encrypted then
        return nil
    end
    return xorEncrypt(base64Decode(encrypted), ENCRYPTION_KEY .. tostring(placeId))
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ANTI-VM DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:DetectVM()
    local suspiciousIndicators = 0
    
    -- Check for unrealistic ping
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
    if ping < 1 or ping > 1000 then
        suspiciousIndicators = suspiciousIndicators + 1
    end
    
    -- Check for missing user input service
    local success = pcall(function()
        game:GetService("UserInputService"):GetLastInputType()
    end)
    if not success then
        suspiciousIndicators = suspiciousIndicators + 1
    end
    
    -- Check player count
    if #game:GetService("Players"):GetPlayers() < 1 then
        suspiciousIndicators = suspiciousIndicators + 1
    end
    
    return suspiciousIndicators < 2
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SECURE LOGGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:SecureLog(action, data)
    local success, result = pcall(function()
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        
        -- Rate limit check
        local canSend, errorMsg = RateLimiter:Check(player.UserId)
        if not canSend then

            return
        end
        
        local embed = {
            {
                title = "ğŸ” " .. action,
                color = action:find("Success") and 5763719 or action:find("Failed") and 15548997 or 5793266,
                fields = {},
                footer = {
                    text = "Hydra Security System | " .. os.date("%Y-%m-%d %H:%M:%S")
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
        }
        
        -- Add fields from data
        for key, value in pairs(data) do
            table.insert(embed[1].fields, {
                name = key,
                value = tostring(value),
                inline = true
            })
        end
        
        -- Send secured request
        self:SecureHttpPost({
            content = "",
            embeds = embed
        })
    end)
    
    if not success then

    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INITIALIZATION & RUNTIME PROTECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function SecurityCore:Initialize()
    -- Run security checks
    if not self:AntiDebug() then
        return false, "Security check failed [0x0001]"
    end
    
    if not self:EnvironmentCheck() then
        return false, "Environment check failed [0x0002]"
    end
    
    if not self:CheckIntegrity() then
        return false, "Integrity check failed [0x0003]"
    end
    
    if not self:DetectVM() then
        return false, "VM detection failed [0x0004]"
    end
    
    -- All checks passed
    return true
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HYDRA LOADER V2 - MAIN LOADER CODE
-- Ultra-modern loading screen with advanced animations
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Key System Configuration
local VERIFICATION_URL = "https://61e5b740-506e-4d91-b132-6eba1d7bef9c-00-2h30njchyh5lj.picard.replit.dev/validate"
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

-- Create Key System ScreenGui
local keySystemGui = Instance.new("ScreenGui")
keySystemGui.Name = "HydraKeySystem"
keySystemGui.ResetOnSpawn = false
keySystemGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
keySystemGui.DisplayOrder = 1000
keySystemGui.IgnoreGuiInset = true
keySystemGui.Parent = game.CoreGui

-- Key System Background
local keyBackground = Instance.new("Frame")
keyBackground.Name = "Background"
keyBackground.Size = UDim2.new(1, 0, 1, 0)
keyBackground.Position = UDim2.new(0, 0, 0, 0)
keyBackground.BackgroundColor3 = Color3.fromRGB(8, 8, 12)
keyBackground.BorderSizePixel = 0
keyBackground.Parent = keySystemGui

-- Animated mesh background pattern
local keyMeshPattern = Instance.new("Frame")
keyMeshPattern.Name = "MeshPattern"
keyMeshPattern.Size = UDim2.new(1, 0, 1, 0)
keyMeshPattern.BackgroundTransparency = 0.95
keyMeshPattern.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
keyMeshPattern.BorderSizePixel = 0
keyMeshPattern.Parent = keyBackground

local keyMeshGradient = Instance.new("UIGradient")
keyMeshGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 255, 100)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 0))
}
keyMeshGradient.Rotation = 45
keyMeshGradient.Parent = keyMeshPattern

-- Animate mesh pattern
task.spawn(function()
	local offset = 0
	while keySystemGui.Parent do
		offset = offset + 0.002
		keyMeshGradient.Offset = Vector2.new(offset, offset)
		RunService.RenderStepped:Wait()
	end
end)

-- Scanline overlay effect
local keyScanlines = Instance.new("Frame")
keyScanlines.Name = "Scanlines"
keyScanlines.Size = UDim2.new(1, 0, 1, 0)
keyScanlines.BackgroundTransparency = 0.97
keyScanlines.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
keyScanlines.BorderSizePixel = 0
keyScanlines.Parent = keyBackground

local keyScanlineGradient = Instance.new("UIGradient")
keyScanlineGradient.Transparency = NumberSequence.new{
	NumberSequenceKeypoint.new(0, 1),
	NumberSequenceKeypoint.new(0.1, 0.9),
	NumberSequenceKeypoint.new(0.2, 1),
	NumberSequenceKeypoint.new(0.3, 0.9),
	NumberSequenceKeypoint.new(0.4, 1),
	NumberSequenceKeypoint.new(0.5, 0.9),
	NumberSequenceKeypoint.new(0.6, 1),
	NumberSequenceKeypoint.new(0.7, 0.9),
	NumberSequenceKeypoint.new(0.8, 1),
	NumberSequenceKeypoint.new(0.9, 0.9),
	NumberSequenceKeypoint.new(1, 1)
}
keyScanlineGradient.Rotation = 90
keyScanlineGradient.Parent = keyScanlines

-- Animate scanlines
task.spawn(function()
	while keySystemGui.Parent do
		for i = 0, 180 do
			if not keySystemGui.Parent then break end
			keyScanlines.Position = UDim2.new(0, 0, i / 180, 0)
			task.wait(0.016)
		end
	end
end)

-- Background floating squares for key system
for i = 1, 80 do
	local bgSquare = Instance.new("Frame")
	bgSquare.Size = UDim2.new(0, math.random(30, 100), 0, math.random(30, 100))
	bgSquare.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	bgSquare.BackgroundTransparency = 0.97
	bgSquare.BorderSizePixel = 0
	bgSquare.Rotation = math.random(0, 360)
	bgSquare.Position = UDim2.new(math.random(0, 100) / 100, 0, math.random(0, 100) / 100, 0)
	bgSquare.ZIndex = 2
	bgSquare.Parent = keyBackground
	
	-- Add glow effect to squares
	local squareGlow = Instance.new("UIStroke")
	squareGlow.Color = Color3.fromRGB(100, 255, 100)
	squareGlow.Thickness = 2
	squareGlow.Transparency = 0.95
	squareGlow.Parent = bgSquare
	
	local bgSquareCorner = Instance.new("UICorner")
	bgSquareCorner.CornerRadius = UDim.new(0, math.random(5, 15))
	bgSquareCorner.Parent = bgSquare
	
	local bgSquareStroke = Instance.new("UIStroke")
	bgSquareStroke.Color = Color3.fromRGB(100, 255, 100)
	bgSquareStroke.Thickness = 1
	bgSquareStroke.Transparency = 0.9
	bgSquareStroke.Parent = bgSquare
	
	-- Floating animation
	task.spawn(function()
		while keySystemGui.Parent do
			local randomX = math.random(0, 100) / 100
			local randomY = math.random(0, 100) / 100
			local duration = math.random(15, 30)
			TweenService:Create(bgSquare, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Position = UDim2.new(randomX, 0, randomY, 0)
			}):Play()
			task.wait(duration)
		end
	end)
	
	-- Rotation
	task.spawn(function()
		local rotSpeed = math.random(2, 8) / 10 * (math.random(0, 1) == 0 and 1 or -1)
		while keySystemGui.Parent do
			bgSquare.Rotation = bgSquare.Rotation + rotSpeed
			RunService.RenderStepped:Wait()
		end
	end)
end

-- Key System Container Shadows
local keyShadow3 = Instance.new("Frame")
keyShadow3.Size = UDim2.new(0, 530, 0, 390)
keyShadow3.Position = UDim2.new(0.5, 10, 0.5, 10)
keyShadow3.AnchorPoint = Vector2.new(0.5, 0.5)
keyShadow3.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
keyShadow3.BackgroundTransparency = 0.95
keyShadow3.BorderSizePixel = 0
keyShadow3.ZIndex = 7
keyShadow3.Parent = keyBackground

local keyShadow3Corner = Instance.new("UICorner")
keyShadow3Corner.CornerRadius = UDim.new(0, 22)
keyShadow3Corner.Parent = keyShadow3

local keyShadow2 = Instance.new("Frame")
keyShadow2.Size = UDim2.new(0, 520, 0, 380)
keyShadow2.Position = UDim2.new(0.5, 7, 0.5, 7)
keyShadow2.AnchorPoint = Vector2.new(0.5, 0.5)
keyShadow2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
keyShadow2.BackgroundTransparency = 0.8
keyShadow2.BorderSizePixel = 0
keyShadow2.ZIndex = 8
keyShadow2.Parent = keyBackground

local keyShadow2Corner = Instance.new("UICorner")
keyShadow2Corner.CornerRadius = UDim.new(0, 21)
keyShadow2Corner.Parent = keyShadow2

local keyShadow1 = Instance.new("Frame")
keyShadow1.Size = UDim2.new(0, 510, 0, 370)
keyShadow1.Position = UDim2.new(0.5, 4, 0.5, 4)
keyShadow1.AnchorPoint = Vector2.new(0.5, 0.5)
keyShadow1.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
keyShadow1.BackgroundTransparency = 0.6
keyShadow1.BorderSizePixel = 0
keyShadow1.ZIndex = 9
keyShadow1.Parent = keyBackground

local keyShadow1Corner = Instance.new("UICorner")
keyShadow1Corner.CornerRadius = UDim.new(0, 20)
keyShadow1Corner.Parent = keyShadow1

-- Key System Container
local keyContainer = Instance.new("Frame")
keyContainer.Name = "KeyContainer"
keyContainer.Size = UDim2.new(0, 500, 0, 360)
keyContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
keyContainer.AnchorPoint = Vector2.new(0.5, 0.5)
keyContainer.BackgroundColor3 = Color3.fromRGB(10, 12, 15)
keyContainer.BackgroundTransparency = 0.1
keyContainer.BorderSizePixel = 0
keyContainer.ZIndex = 10
keyContainer.Parent = keyBackground

local keyContainerCorner = Instance.new("UICorner")
keyContainerCorner.CornerRadius = UDim.new(0, 20)
keyContainerCorner.Parent = keyContainer

-- Glass overlay
local keyGlassOverlay = Instance.new("Frame")
keyGlassOverlay.Size = UDim2.new(1, 0, 0.5, 0)
keyGlassOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
keyGlassOverlay.BackgroundTransparency = 0.97
keyGlassOverlay.BorderSizePixel = 0
keyGlassOverlay.ZIndex = 10
keyGlassOverlay.Parent = keyContainer

local keyGlassCorner = Instance.new("UICorner")
keyGlassCorner.CornerRadius = UDim.new(0, 20)
keyGlassCorner.Parent = keyGlassOverlay

local keyBorderGlow = Instance.new("UIStroke")
keyBorderGlow.Color = Color3.fromRGB(100, 255, 100)
keyBorderGlow.Thickness = 3
keyBorderGlow.Transparency = 0.3
keyBorderGlow.Parent = keyContainer

local keyBorderGlow2 = Instance.new("Frame")
keyBorderGlow2.Size = UDim2.new(1, 6, 1, 6)
keyBorderGlow2.Position = UDim2.new(0.5, 0, 0.5, 0)
keyBorderGlow2.AnchorPoint = Vector2.new(0.5, 0.5)
keyBorderGlow2.BackgroundTransparency = 1
keyBorderGlow2.BorderSizePixel = 0
keyBorderGlow2.ZIndex = 9
keyBorderGlow2.Parent = keyContainer

local keyBorderStroke2 = Instance.new("UIStroke")
keyBorderStroke2.Color = Color3.fromRGB(100, 255, 100)
keyBorderStroke2.Thickness = 1
keyBorderStroke2.Transparency = 0.7
keyBorderStroke2.Parent = keyBorderGlow2

local keyBorder2Corner = Instance.new("UICorner")
keyBorder2Corner.CornerRadius = UDim.new(0, 22)
keyBorder2Corner.Parent = keyBorderGlow2

-- Advanced particle system around container
for i = 1, 15 do
	local particle = Instance.new("Frame")
	particle.Size = UDim2.new(0, math.random(3, 8), 0, math.random(3, 8))
	particle.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	particle.BackgroundTransparency = 0.3
	particle.BorderSizePixel = 0
	particle.ZIndex = 15
	particle.Parent = keyContainer
	
	local particleCorner = Instance.new("UICorner")
	particleCorner.CornerRadius = UDim.new(1, 0)
	particleCorner.Parent = particle
	
	-- Orbit animation around container edges
	task.spawn(function()
		local angle = (i / 15) * 360
		while keySystemGui.Parent do
			angle = angle + 0.5
			local rad = math.rad(angle)
			local radius = 0.52
			local x = 0.5 + math.cos(rad) * radius
			local y = 0.5 + math.sin(rad) * radius
			particle.Position = UDim2.new(x, 0, y, 0)
			
			-- Pulse effect
			local pulseSize = 4 + math.sin(angle / 10) * 3
			particle.Size = UDim2.new(0, pulseSize, 0, pulseSize)
			particle.BackgroundTransparency = 0.3 + math.abs(math.sin(angle / 20)) * 0.5
			
			RunService.RenderStepped:Wait()
		end
	end)
end

-- Hexagon pattern background in container
for i = 1, 20 do
	local hex = Instance.new("Frame")
	hex.Size = UDim2.new(0, math.random(30, 60), 0, math.random(30, 60))
	hex.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	hex.BackgroundTransparency = 0.96
	hex.BorderSizePixel = 0
	hex.Rotation = math.random(0, 360)
	hex.ZIndex = 11
	hex.Parent = keyContainer
	
	local hexCorner = Instance.new("UICorner")
	hexCorner.CornerRadius = UDim.new(0, math.random(4, 10))
	hexCorner.Parent = hex
	
	local hexStroke = Instance.new("UIStroke")
	hexStroke.Color = Color3.fromRGB(100, 255, 100)
	hexStroke.Thickness = 1
	hexStroke.Transparency = 0.92
	hexStroke.Parent = hex
	
	hex.Position = UDim2.new(math.random(-10, 110) / 100, 0, math.random(-10, 110) / 100, 0)
	
	-- Float animation
	task.spawn(function()
		while keySystemGui.Parent do
			local randomX = math.random(-10, 110) / 100
			local randomY = math.random(-10, 110) / 100
			local duration = math.random(8, 15)
			TweenService:Create(hex, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Position = UDim2.new(randomX, 0, randomY, 0)
			}):Play()
			task.wait(duration)
		end
	end)
	
	-- Rotation
	task.spawn(function()
		local rotSpeed = math.random(2, 6) / 10 * (math.random(0, 1) == 0 and 1 or -1)
		while keySystemGui.Parent do
			hex.Rotation = hex.Rotation + rotSpeed
			RunService.RenderStepped:Wait()
		end
	end)
end

-- Title
local keyTitle = Instance.new("TextLabel")
keyTitle.Size = UDim2.new(1, 0, 0, 55)
keyTitle.Position = UDim2.new(0, 0, 0.04, 0)
keyTitle.BackgroundTransparency = 1
keyTitle.Text = "HYDRA HUB"
keyTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
keyTitle.TextSize = 36
keyTitle.Font = Enum.Font.GothamBold
keyTitle.TextStrokeTransparency = 0
keyTitle.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
keyTitle.ZIndex = 12
keyTitle.Parent = keyContainer

local keyTitleGradient = Instance.new("UIGradient")
keyTitleGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 255, 100)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 255, 200)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 255, 100))
}
keyTitleGradient.Parent = keyTitle

-- Animate title gradient
task.spawn(function()
	while keySystemGui.Parent do
		for i = 0, 360, 2 do
			if not keySystemGui.Parent then break end
			keyTitleGradient.Rotation = i
			task.wait(0.03)
		end
	end
end)

-- Subtitle
local keySubtitle = Instance.new("TextLabel")
keySubtitle.Size = UDim2.new(1, 0, 0, 22)
keySubtitle.Position = UDim2.new(0, 0, 0.195, 0)
keySubtitle.BackgroundTransparency = 1
keySubtitle.Text = "KEY SYSTEM VERIFICATION"
keySubtitle.TextColor3 = Color3.fromRGB(150, 255, 150)
keySubtitle.TextSize = 13
keySubtitle.Font = Enum.Font.GothamBold
keySubtitle.TextTransparency = 0.3
keySubtitle.ZIndex = 12
keySubtitle.Parent = keyContainer

-- Key Input Box (Repositioned)
local keyInputBox = Instance.new("TextBox")
keyInputBox.Size = UDim2.new(0.75, 0, 0, 45)
keyInputBox.Position = UDim2.new(0.5, 0, 0.42, 0)
keyInputBox.AnchorPoint = Vector2.new(0.5, 0.5)
keyInputBox.BackgroundColor3 = Color3.fromRGB(15, 18, 22)
keyInputBox.BackgroundTransparency = 1
keyInputBox.BorderSizePixel = 0
keyInputBox.Text = ""
keyInputBox.PlaceholderText = "Enter Key Code..."
keyInputBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
keyInputBox.TextColor3 = Color3.fromRGB(200, 255, 200)
keyInputBox.TextSize = 16
keyInputBox.Font = Enum.Font.Gotham
keyInputBox.TextXAlignment = Enum.TextXAlignment.Center
keyInputBox.ClearTextOnFocus = false
keyInputBox.ZIndex = 12
keyInputBox.Parent = keyContainer

local keyInputCorner = Instance.new("UICorner")
keyInputCorner.CornerRadius = UDim.new(0, 10)
keyInputCorner.Parent = keyInputBox

-- Typing indicator for input box
local typingIndicator = Instance.new("TextLabel")
typingIndicator.Size = UDim2.new(0, 40, 0, 20)
typingIndicator.Position = UDim2.new(1, -50, 0.5, 0)
typingIndicator.AnchorPoint = Vector2.new(0, 0.5)
typingIndicator.BackgroundTransparency = 1
typingIndicator.Text = ""
typingIndicator.TextColor3 = Color3.fromRGB(100, 255, 100)
typingIndicator.TextSize = 18
typingIndicator.Font = Enum.Font.GothamBold
typingIndicator.ZIndex = 13
typingIndicator.Parent = keyInputBox

-- Animate typing indicator
keyInputBox:GetPropertyChangedSignal("Text"):Connect(function()
	if #keyInputBox.Text > 0 then
		task.spawn(function()
			for i = 1, 3 do
				typingIndicator.Text = string.rep(".", i)
				task.wait(0.3)
			end
			typingIndicator.Text = ""
		end)
	end
end)

-- Advanced glow layer for input
local inputGlow = Instance.new("Frame")
inputGlow.Size = UDim2.new(1, 10, 1, 10)
inputGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
inputGlow.AnchorPoint = Vector2.new(0.5, 0.5)
inputGlow.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
inputGlow.BackgroundTransparency = 1
inputGlow.BorderSizePixel = 0
inputGlow.ZIndex = 11
inputGlow.Parent = keyInputBox

local inputGlowCorner = Instance.new("UICorner")
inputGlowCorner.CornerRadius = UDim.new(0, 12)
inputGlowCorner.Parent = inputGlow

-- Input box focus effects with advanced animations
keyInputBox.Focused:Connect(function()
	TweenService:Create(keyInputBox, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.new(0.78, 0, 0, 47)
	}):Play()
	TweenService:Create(inputGlow, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 0.7,
		Size = UDim2.new(1, 20, 1, 20)
	}):Play()
end)

keyInputBox.FocusLost:Connect(function()
	TweenService:Create(keyInputBox, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.new(0.75, 0, 0, 45)
	}):Play()
	TweenService:Create(inputGlow, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 10, 1, 10)
	}):Play()
end)

-- Get Key Button (Repositioned)
local getKeyButton = Instance.new("TextButton")
getKeyButton.Size = UDim2.new(0.75, 0, 0, 42)
getKeyButton.Position = UDim2.new(0.5, 0, 0.78, 0)
getKeyButton.AnchorPoint = Vector2.new(0.5, 0.5)
getKeyButton.BackgroundColor3 = Color3.fromRGB(20, 25, 30)
getKeyButton.BorderSizePixel = 0
getKeyButton.Text = "GET KEY"
getKeyButton.TextColor3 = Color3.fromRGB(100, 255, 100)
getKeyButton.TextSize = 18
getKeyButton.Font = Enum.Font.GothamBold
getKeyButton.ZIndex = 12
getKeyButton.Parent = keyContainer

local getKeyButtonCorner = Instance.new("UICorner")
getKeyButtonCorner.CornerRadius = UDim.new(0, 10)
getKeyButtonCorner.Parent = getKeyButton

local getKeyButtonStroke = Instance.new("UIStroke")
getKeyButtonStroke.Color = Color3.fromRGB(100, 255, 100)
getKeyButtonStroke.Thickness = 2
getKeyButtonStroke.Transparency = 0.5
getKeyButtonStroke.Parent = getKeyButton

-- Advanced glow for GET KEY button
local getKeyGlow = Instance.new("Frame")
getKeyGlow.Size = UDim2.new(1, 0, 1, 0)
getKeyGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
getKeyGlow.AnchorPoint = Vector2.new(0.5, 0.5)
getKeyGlow.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
getKeyGlow.BackgroundTransparency = 1
getKeyGlow.BorderSizePixel = 0
getKeyGlow.ZIndex = 11
getKeyGlow.Parent = getKeyButton

local getKeyGlowCorner = Instance.new("UICorner")
getKeyGlowCorner.CornerRadius = UDim.new(0, 10)
getKeyGlowCorner.Parent = getKeyGlow

-- Get Key Button effects with advanced animations
getKeyButton.MouseEnter:Connect(function()
	TweenService:Create(getKeyButton, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = Color3.fromRGB(30, 35, 40),
		Size = UDim2.new(0.78, 0, 0, 45)
	}):Play()
	TweenService:Create(getKeyButtonStroke, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = 0.2,
		Thickness = 3
	}):Play()
	TweenService:Create(getKeyGlow, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 0.85,
		Size = UDim2.new(1, 15, 1, 15)
	}):Play()
end)

getKeyButton.MouseLeave:Connect(function()
	TweenService:Create(getKeyButton, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = Color3.fromRGB(20, 25, 30),
		Size = UDim2.new(0.75, 0, 0, 42)
	}):Play()
	TweenService:Create(getKeyButtonStroke, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = 0.5,
		Thickness = 2
	}):Play()
	TweenService:Create(getKeyGlow, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0)
	}):Play()
end)

-- Add loading bar to GET KEY button
local loadingBar = Instance.new("Frame")
loadingBar.Size = UDim2.new(0, 0, 0, 3)
loadingBar.Position = UDim2.new(0, 0, 1, -3)
loadingBar.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
loadingBar.BorderSizePixel = 0
loadingBar.ZIndex = 13
loadingBar.Parent = getKeyButton

local loadingBarCorner = Instance.new("UICorner")
loadingBarCorner.CornerRadius = UDim.new(1, 0)
loadingBarCorner.Parent = loadingBar

getKeyButton.MouseButton1Click:Connect(function()
	-- Discord invite link
	local discordUrl = "https://discord.gg/vPnamBTWzU"
	
	-- Method 1: Most common - openbrowser function (Script-Ware, KRNL, Fluxus, etc.)
	local success1 = pcall(function()
		if openbrowser then
			openbrowser(discordUrl)
			return true
		end
	end)
	
	-- Method 2: Synapse X specific
	local success2 = pcall(function()
		if syn and syn.request then
			syn.request({
				Url = discordUrl,
				Method = "GET",
				Headers = {
					["User-Agent"] = "Mozilla/5.0"
				}
			})
			return true
		end
	end)
	
	-- Method 3: Alternative openbrowser naming
	local success3 = pcall(function()
		if browser then
			browser(discordUrl)
			return true
		end
	end)
	
	-- Method 4: open_browser variation
	local success4 = pcall(function()
		if open_browser then
			open_browser(discordUrl)
			return true
		end
	end)
	
	-- Method 5: request function (http_request)
	local success5 = pcall(function()
		if request then
			request({
				Url = discordUrl,
				Method = "GET"
			})
			return true
		end
	end)
	
	-- Method 6: http_request
	local success6 = pcall(function()
		if http_request then
			http_request({
				Url = discordUrl,
				Method = "GET"
			})
			return true
		end
	end)
	
	-- Method 7: HttpGet redirect
	local success7 = pcall(function()
		game:HttpGet(discordUrl)
	end)
	
	-- Method 8: Roblox's Browser Window (if available)
	local success8 = pcall(function()
		if game.OpenBrowserWindow then
			game:OpenBrowserWindow(discordUrl)
			return true
		end
	end)
	
	-- Method 9: Clipboard fallback
	pcall(function()
		if setclipboard then
			setclipboard(discordUrl)
		end
	end)
	
	-- Button feedback animation with loading bar
	getKeyButton.Text = "OPENING..."
	TweenService:Create(getKeyButton, TweenInfo.new(0.2, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
		BackgroundColor3 = Color3.fromRGB(50, 200, 50)
	}):Play()
	
	-- Animate loading bar
	TweenService:Create(loadingBar, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.new(1, 0, 0, 3)
	}):Play()
	
	task.wait(1)
	getKeyButton.Text = "âœ“ LINK COPIED!"
	task.wait(1.5)
	
	TweenService:Create(getKeyButton, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = Color3.fromRGB(20, 25, 30)
	}):Play()
	TweenService:Create(loadingBar, TweenInfo.new(0.3), {
		Size = UDim2.new(0, 0, 0, 3)
	}):Play()
	getKeyButton.Text = "GET KEY"
end)

-- Submit Button (Clean modern design)
local submitButton = Instance.new("TextButton")
submitButton.Size = UDim2.new(0.75, 0, 0, 45)
submitButton.Position = UDim2.new(0.5, 0, 0.60, 0)
submitButton.AnchorPoint = Vector2.new(0.5, 0.5)
submitButton.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
submitButton.BorderSizePixel = 0
submitButton.Text = "VERIFY KEY"
submitButton.TextColor3 = Color3.fromRGB(0, 0, 0)
submitButton.TextSize = 20
submitButton.Font = Enum.Font.GothamBold
submitButton.ZIndex = 12
submitButton.Parent = keyContainer

local submitButtonCorner = Instance.new("UICorner")
submitButtonCorner.CornerRadius = UDim.new(0, 12)
submitButtonCorner.Parent = submitButton

-- Submit button hover effect with modern animations
submitButton.MouseEnter:Connect(function()
	TweenService:Create(submitButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		BackgroundColor3 = Color3.fromRGB(150, 255, 150),
		Size = UDim2.new(0.78, 0, 0, 48),
		Rotation = 2
	}):Play()
end)

submitButton.MouseLeave:Connect(function()
	TweenService:Create(submitButton, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundColor3 = Color3.fromRGB(100, 255, 100),
		Size = UDim2.new(0.75, 0, 0, 45),
		Rotation = 0
	}):Play()
end)

-- Add chevron icon to submit button
local submitIcon = Instance.new("TextLabel")
submitIcon.Size = UDim2.new(0, 20, 0, 20)
submitIcon.Position = UDim2.new(1, -30, 0.5, 0)
submitIcon.AnchorPoint = Vector2.new(0.5, 0.5)
submitIcon.BackgroundTransparency = 1
submitIcon.Text = "â†’"
submitIcon.TextColor3 = Color3.fromRGB(0, 0, 0)
submitIcon.TextSize = 20
submitIcon.Font = Enum.Font.GothamBold
submitIcon.ZIndex = 13
submitIcon.Parent = submitButton

-- Animate icon
task.spawn(function()
	while keySystemGui.Parent do
		TweenService:Create(submitIcon, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			Position = UDim2.new(1, -25, 0.5, 0)
		}):Play()
		task.wait(0.8)
		TweenService:Create(submitIcon, TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			Position = UDim2.new(1, -30, 0.5, 0)
		}):Play()
		task.wait(0.8)
	end
end)

-- Status Text
local keyStatusText = Instance.new("TextLabel")
keyStatusText.Size = UDim2.new(1, 0, 0, 25)
keyStatusText.Position = UDim2.new(0, 0, 0.92, 0)
keyStatusText.BackgroundTransparency = 1
keyStatusText.Text = ""
keyStatusText.TextColor3 = Color3.fromRGB(255, 100, 100)
keyStatusText.TextSize = 14
keyStatusText.Font = Enum.Font.GothamMedium
keyStatusText.ZIndex = 12
keyStatusText.Parent = keyContainer

-- Forget Saved Key Button (Small, subtle button)
local forgetKeyButton = Instance.new("TextButton")
forgetKeyButton.Size = UDim2.new(0.4, 0, 0, 30)
forgetKeyButton.Position = UDim2.new(0.5, 0, 0.75, 0)
forgetKeyButton.AnchorPoint = Vector2.new(0.5, 0.5)
forgetKeyButton.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
forgetKeyButton.BackgroundTransparency = 0.5
forgetKeyButton.BorderSizePixel = 0
forgetKeyButton.Text = "Forget Saved Key"
forgetKeyButton.TextColor3 = Color3.fromRGB(200, 200, 200)
forgetKeyButton.TextSize = 12
forgetKeyButton.Font = Enum.Font.Gotham
forgetKeyButton.ZIndex = 12
forgetKeyButton.Visible = false
forgetKeyButton.Parent = keyContainer

local forgetKeyCorner = Instance.new("UICorner")
forgetKeyCorner.CornerRadius = UDim.new(0, 8)
forgetKeyCorner.Parent = forgetKeyButton

local forgetKeyStroke = Instance.new("UIStroke")
forgetKeyStroke.Color = Color3.fromRGB(255, 100, 100)
forgetKeyStroke.Thickness = 1
forgetKeyStroke.Transparency = 0.7
forgetKeyStroke.Parent = forgetKeyButton

-- Forget key button hover
forgetKeyButton.MouseEnter:Connect(function()
	TweenService:Create(forgetKeyButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.2,
		TextColor3 = Color3.fromRGB(255, 100, 100)
	}):Play()
	TweenService:Create(forgetKeyStroke, TweenInfo.new(0.2), {
		Transparency = 0.3
	}):Play()
end)

forgetKeyButton.MouseLeave:Connect(function()
	TweenService:Create(forgetKeyButton, TweenInfo.new(0.2), {
		BackgroundTransparency = 0.5,
		TextColor3 = Color3.fromRGB(200, 200, 200)
	}):Play()
	TweenService:Create(forgetKeyStroke, TweenInfo.new(0.2), {
		Transparency = 0.7
	}):Play()
end)

-- Forget key button click
forgetKeyButton.MouseButton1Click:Connect(function()
	local deleteSuccess = deleteKey()
	if deleteSuccess then
		forgetKeyButton.Visible = false
		keyInputBox.Text = ""
		keyStatusText.Text = "Saved key deleted - enter new key"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 200, 100)
	else
		keyStatusText.Text = "Failed to delete saved key"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 100, 100)
	end
end)

-- Pulse border animation
task.spawn(function()
	while keySystemGui.Parent do
		TweenService:Create(keyBorderGlow, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.1,
			Thickness = 4
		}):Play()
		TweenService:Create(keyBorderStroke2, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.4
		}):Play()
		task.wait(2)
		TweenService:Create(keyBorderGlow, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.6,
			Thickness = 2
		}):Play()
		TweenService:Create(keyBorderStroke2, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.9
		}):Play()
		task.wait(2)
	end
end)

-- Advanced Entrance Animation with wave effect
keyContainer.Size = UDim2.new(0, 0, 0, 0)
keyContainer.Rotation = -90
keyShadow1.Size = UDim2.new(0, 0, 0, 0)
keyShadow2.Size = UDim2.new(0, 0, 0, 0)
keyShadow3.Size = UDim2.new(0, 0, 0, 0)

-- Hide all content initially
for _, child in pairs(keyContainer:GetChildren()) do
	if child:IsA("TextLabel") then
		child.TextTransparency = 1
	elseif child:IsA("TextButton") or child:IsA("TextBox") then
		child.BackgroundTransparency = 1
		child.TextTransparency = 1
		if child:FindFirstChild("UIStroke") then
			child.UIStroke.Transparency = 1
		end
	end
end

local keyEntranceTween1 = TweenService:Create(keyContainer, TweenInfo.new(1, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
	Size = UDim2.new(0, 500, 0, 360),
	Rotation = 0
})
local keyEntranceTween2 = TweenService:Create(keyShadow1, TweenInfo.new(1, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
	Size = UDim2.new(0, 510, 0, 370)
})
local keyEntranceTween3 = TweenService:Create(keyShadow2, TweenInfo.new(1.05, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
	Size = UDim2.new(0, 520, 0, 380)
})
local keyEntranceTween4 = TweenService:Create(keyShadow3, TweenInfo.new(1.1, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
	Size = UDim2.new(0, 530, 0, 390)
})

keyEntranceTween1:Play()
task.wait(0.05)
keyEntranceTween2:Play()
task.wait(0.05)
keyEntranceTween3:Play()
task.wait(0.05)
keyEntranceTween4:Play()

-- Wave animation for content reveal
task.wait(0.6)

-- Fade in title
TweenService:Create(keyTitle, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
	TextTransparency = 0
}):Play()

task.wait(0.1)

-- Fade in subtitle
TweenService:Create(keySubtitle, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
	TextTransparency = 0.3
}):Play()

task.wait(0.15)

-- Fade in input box
TweenService:Create(keyInputBox, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
	BackgroundTransparency = 0,
	TextTransparency = 0
}):Play()
if keyInputStroke then
	TweenService:Create(keyInputStroke, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = 0.7
	}):Play()
end

task.wait(0.1)

-- Fade in GET KEY button
TweenService:Create(getKeyButton, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
	BackgroundTransparency = 0,
	TextTransparency = 0
}):Play()
if getKeyButtonStroke then
	TweenService:Create(getKeyButtonStroke, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = 0.5
	}):Play()
end

task.wait(0.1)

-- Fade in submit button
TweenService:Create(submitButton, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
	BackgroundTransparency = 0,
	TextTransparency = 0
}):Play()

-- Key Validation Function
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ULTRA-SECURE KEY STORAGE SYSTEM V4.0
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local STORAGE_KEY_1 = "HydraVault_Omega_Protocol_2026_Alpha_Shield"
local STORAGE_KEY_2 = "QuantumLock_SecureKey_Beta_Encryption_Layer"
local STORAGE_KEY_3 = "DiamondProtection_Gamma_SecureStorage_Final"
local STORAGE_FILE = "hydra_quantum_vault_v4.hkey"

-- Get system HWID (ultra reliable)
local function getSystemHWID()
	local hwid
	
	-- Try all executor HWID functions
	if gethwid then
		hwid = gethwid()
	elseif get_hwid then
		hwid = get_hwid()
	elseif GetHWID then
		hwid = GetHWID()
	elseif hwid_get then
		hwid = hwid_get()
	end
	
	-- Fallback to RbxAnalytics ClientId (most stable)
	if not hwid or hwid == "" or hwid == nil then
		local success, clientId = pcall(function()
			return game:GetService("RbxAnalyticsService"):GetClientId()
		end)
		if success and clientId then
			hwid = "RBXID_" .. clientId
		else
			-- Last resort - stable UserID fingerprint
			hwid = "USRID_" .. tostring(game.Players.LocalPlayer.UserId)
		end
	end
	
	return tostring(hwid)
end

-- Enhanced save with integrity check and anti-tamper signature
local function saveKey(key, username, hwid)
	-- Verify file system support
	if not writefile or not readfile or not isfile then
		return false, "File system not supported"
	end
	
	-- Validate inputs
	if not key or key == "" then
		return false, "Invalid key"
	end
	if not username or username == "" then
		return false, "Invalid username"
	end
	if not hwid or hwid == "" then
		return false, "Invalid HWID"
	end
	
	-- Create cryptographic signature to prevent tampering
	local signatureData = key .. username .. hwid .. "HYDRA_VAULT_2026_SIGNATURE"
	local signature = ""
	for i = 1, #signatureData do
		local byte = string.byte(signatureData, i)
		signature = signature .. string.format("%02x", (byte * 7 + i * 13) % 256)
	end
	
	-- Create data package with checksum and signature
	local dataTable = {
		key = tostring(key),
		username = tostring(username),
		hwid = tostring(hwid),
		timestamp = os.time(),
		version = "4.0",
		checksum = string.len(key) + string.len(username) + string.len(hwid),
		signature = signature
	}
	
	-- Encode to JSON
	local success1, jsonData = pcall(function()
		return HttpService:JSONEncode(dataTable)
	end)
	
	if not success1 or not jsonData then
		return false, "JSON encoding failed"
	end
	
	-- Apply 11-layer ultra encryption
	local success2, encrypted = pcall(function()
		return ultraEncrypt(jsonData, STORAGE_KEY_1, STORAGE_KEY_2, STORAGE_KEY_3)
	end)
	
	if not success2 or not encrypted or encrypted == "" then
		return false, "Encryption failed"
	end
	
	-- Write to file with error handling
	local success3, writeErr = pcall(function()
		writefile(STORAGE_FILE, encrypted)
	end)
	
	if not success3 then
		return false, "File write failed: " .. tostring(writeErr)
	end
	
	-- Verify the file was written correctly
	task.wait(0.2)
	if not isfile(STORAGE_FILE) then
		return false, "File verification failed"
	end
	
	-- Read back and verify integrity
	local success4, readBack = pcall(function()
		return readfile(STORAGE_FILE)
	end)
	
	if not success4 or not readBack or readBack == "" then
		return false, "File read-back failed"
	end
	
	if readBack ~= encrypted then
		return false, "Data integrity check failed"
	end
	
	return true, "Key saved successfully"
end

-- Enhanced load with validation
local function loadKey()
	-- Verify file system support
	if not readfile or not isfile then
		return nil, "File system not supported"
	end
	
	-- Check if file exists
	if not isfile(STORAGE_FILE) then
		return nil, "No saved key found"
	end
	
	-- Read encrypted file
	local success1, encrypted = pcall(function()
		return readfile(STORAGE_FILE)
	end)
	
	if not success1 or not encrypted or encrypted == "" then
		return nil, "File read failed"
	end
	
	-- Decrypt data
	local success2, decrypted = pcall(function()
		return ultraDecrypt(encrypted, STORAGE_KEY_1, STORAGE_KEY_2, STORAGE_KEY_3)
	end)
	
	if not success2 or not decrypted or decrypted == "" then
		return nil, "Decryption failed"
	end
	
	-- Parse JSON
	local success3, data = pcall(function()
		return HttpService:JSONDecode(decrypted)
	end)
	
	if not success3 or not data then
		return nil, "JSON parsing failed"
	end
	
	-- Validate data structure
	if type(data) ~= "table" then
		return nil, "Invalid data structure"
	end
	
	if not data.key or not data.username or not data.hwid then
		return nil, "Missing required fields"
	end
	
	-- Verify checksum
	local expectedChecksum = string.len(data.key) + string.len(data.username) + string.len(data.hwid)
	if data.checksum and data.checksum ~= expectedChecksum then
		return nil, "Checksum verification failed"
	end
	
	return data, "Success"
end

-- Safe delete with verification
local function deleteKey()
	if not delfile or not isfile then
		return false
	end
	
	if isfile(STORAGE_FILE) then
		local success = pcall(function()
			delfile(STORAGE_FILE)
		end)
		return success
	end
	
	return true
end

-- Validate saved data against current system
local function validateSavedKey(savedData)
	if not savedData or type(savedData) ~= "table" then
		return false, "No saved data"
	end
	
	
	-- Verify all required fields exist
	if not savedData.key or savedData.key == "" then
		return false, "Missing key"
	end
	
	if not savedData.username or savedData.username == "" then
		return false, "Missing username"
	end
	
	if not savedData.hwid or savedData.hwid == "" then
		return false, "Missing HWID"
	end
	
	-- Get current credentials
	local currentUsername = game.Players.LocalPlayer.Name
	local currentHwid = getSystemHWID()
	
	
	-- Username validation
	if savedData.username ~= currentUsername then
		return false, "Username mismatch (saved for different user)"
	end
	
	-- HWID validation
	if savedData.hwid ~= currentHwid then
		return false, "HWID mismatch (different device)"
	end
	
	return true, "Validation passed"
end

local function validateKey(keyOverride)
	local enteredKey = keyOverride or keyInputBox.Text
	
	if not enteredKey or enteredKey == "" then
		keyStatusText.Text = "Please enter a key"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 100, 100)
		return false
	end
	
	keyStatusText.Text = "Verifying key..."
	keyStatusText.TextColor3 = Color3.fromRGB(200, 200, 200)
	submitButton.Active = false
	
	-- Get Roblox username
	local robloxUsername = game.Players.LocalPlayer.Name
	
	-- Get system HWID using centralized function
	local hwid = getSystemHWID()
	
	-- URL encode function
	local function urlEncode(str)
		if str then
			str = string.gsub(str, "\n", "\r\n")
			str = string.gsub(str, "([^%w %-%_%.%~])", function(c)
				return string.format("%%%02X", string.byte(c))
			end)
			str = string.gsub(str, " ", "+")
		end
		return str
	end
	
	-- Build validation URL with properly encoded parameters
	local validationUrl = VERIFICATION_URL .. "?key=" .. urlEncode(enteredKey) .. "&username=" .. urlEncode(robloxUsername) .. "&hwid=" .. urlEncode(hwid)




	-- Verify key with server using GET request
	local success, response = pcall(function()
		return game:HttpGet(validationUrl)
	end)
	
	if not success then

		keyStatusText.Text = "Server Error: Check Console (F9)"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 100, 100)
		submitButton.Active = true
		submitButton.Text = "VERIFY KEY"



		return false
	end

	local parseSuccess, data = pcall(function()
		return HttpService:JSONDecode(response)
	end)
	
	if not parseSuccess then

		keyStatusText.Text = "Invalid server response"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 100, 100)
		submitButton.Active = true
		submitButton.Text = "VERIFY KEY"
		return false
	end
	
	if data.valid then
		keyStatusText.Text = "Key Valid! Loading..."
		keyStatusText.TextColor3 = Color3.fromRGB(100, 255, 100)
		
		-- Save key securely for auto-login
		local saveSuccess, saveMsg = saveKey(enteredKey, robloxUsername, hwid)
		if not saveSuccess then
			keyStatusText.Text = "Key valid but save failed: " .. tostring(saveMsg)
		end
		
		-- Success animation
		submitButton.Text = "SUCCESS!"
		for i = 1, 3 do
			TweenService:Create(keyBorderGlow, TweenInfo.new(0.2), {
				Transparency = 0,
				Thickness = 5
			}):Play()
			task.wait(0.2)
			TweenService:Create(keyBorderGlow, TweenInfo.new(0.2), {
				Transparency = 0.3,
				Thickness = 3
			}):Play()
			task.wait(0.2)
		end
		
		-- Fade out key system with shadows
		TweenService:Create(keyContainer, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, 0),
			Rotation = 90
		}):Play()
		
		TweenService:Create(keyShadow1, TweenInfo.new(0.55, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, 0)
		}):Play()
		
		TweenService:Create(keyShadow2, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, 0)
		}):Play()
		
		TweenService:Create(keyShadow3, TweenInfo.new(0.65, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, 0)
		}):Play()
		
		task.wait(0.7)
		keySystemGui:Destroy()
		
		submitButton.Active = true
		return true
	else
		keyStatusText.Text = data.error or "Invalid Key"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 100, 100)
		submitButton.Text = "INVALID!"
		submitButton.Active = true

		-- Error shake animation
		for i = 1, 3 do
			keyContainer.Position = UDim2.new(0.5, -10, 0.5, 0)
			task.wait(0.05)
			keyContainer.Position = UDim2.new(0.5, 10, 0.5, 0)
			task.wait(0.05)
		end
		keyContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
		
		task.wait(1)
		submitButton.Text = "VERIFY KEY"
		
		return false
	end
end

-- Button Click Handler
submitButton.MouseButton1Click:Connect(function()
	validateKey()
end)

-- Enter Key Handler
keyInputBox.FocusLost:Connect(function(enterPressed)
	if enterPressed then
		validateKey()
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AUTO-LOGIN WITH SAVED KEY V4.0
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Ultra-robust auto-login system
task.spawn(function()
	task.wait(0.8) -- Wait for UI to fully load
	
	-- Attempt to load saved key
	local savedData, loadMsg = loadKey()
	
	-- Debug: Show load status
	if not savedData then
		-- No saved key or load failed - normal first-time use
		forgetKeyButton.Visible = false
		return
	end
	
	-- Validate the saved key data
	local isValid, validMsg = validateSavedKey(savedData)
	
	if not isValid then
		-- Saved key is for different user/device
		keyStatusText.Text = "Saved key invalid: " .. tostring(validMsg)
		keyStatusText.TextColor3 = Color3.fromRGB(255, 150, 100)
		-- Delete invalid key
		deleteKey()
		forgetKeyButton.Visible = false
		return
	end
	
	-- We have a valid saved key - ALWAYS validate with server (no bypass possible)
	keyStatusText.Text = "Found saved key - verifying with server..."
	keyStatusText.TextColor3 = Color3.fromRGB(100, 200, 255)
	forgetKeyButton.Visible = true
	
	-- Visual feedback
	task.wait(0.3)
	
	-- CRITICAL: ALWAYS validate with server API - saved keys can NEVER bypass server validation
	-- This prevents users from editing the saved file to bypass expiration
	local loginSuccess = validateKey(savedData.key)
	
	if loginSuccess then
		-- Auto-login successful - server confirmed key is still valid
		keyStatusText.Text = "Auto-login successful!"
		keyStatusText.TextColor3 = Color3.fromRGB(100, 255, 100)
	else
		-- Key expired or invalid according to SERVER - delete it
		keyStatusText.Text = "Saved key expired - enter new key"
		keyStatusText.TextColor3 = Color3.fromRGB(255, 200, 100)
		keyInputBox.Text = ""
		-- Delete expired key from storage
		deleteKey()
		forgetKeyButton.Visible = false
	end
end)

-- Create ScreenGui
local loader = Instance.new("ScreenGui")
loader.Name = "HydraLoader"
loader.ResetOnSpawn = false
loader.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
loader.DisplayOrder = 999
loader.IgnoreGuiInset = true
loader.Parent = game.CoreGui

-- Main Background with advanced gradient
local background = Instance.new("Frame")
background.Name = "Background"
background.Size = UDim2.new(1, 0, 1, 0)
background.Position = UDim2.new(0, 0, 0, 0)
background.BackgroundColor3 = Color3.fromRGB(8, 8, 12)
background.BorderSizePixel = 0
background.Parent = loader

-- Animated mesh background pattern
local meshPattern = Instance.new("Frame")
meshPattern.Name = "MeshPattern"
meshPattern.Size = UDim2.new(1, 0, 1, 0)
meshPattern.BackgroundTransparency = 0.95
meshPattern.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
meshPattern.BorderSizePixel = 0
meshPattern.Parent = background

local meshGradient = Instance.new("UIGradient")
meshGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 255, 100)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 0))
}
meshGradient.Rotation = 45
meshGradient.Parent = meshPattern

-- Animate mesh pattern
task.spawn(function()
	local offset = 0
	while loader.Parent do
		offset = offset + 0.002
		meshGradient.Offset = Vector2.new(offset, offset)
		RunService.RenderStepped:Wait()
	end
end)

-- Scanline overlay effect
local scanlines = Instance.new("Frame")
scanlines.Name = "Scanlines"
scanlines.Size = UDim2.new(1, 0, 1, 0)
scanlines.BackgroundTransparency = 0.97
scanlines.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
scanlines.BorderSizePixel = 0
scanlines.Parent = background

local scanlineGradient = Instance.new("UIGradient")
scanlineGradient.Transparency = NumberSequence.new{
	NumberSequenceKeypoint.new(0, 1),
	NumberSequenceKeypoint.new(0.1, 0.9),
	NumberSequenceKeypoint.new(0.2, 1),
	NumberSequenceKeypoint.new(0.3, 0.9),
	NumberSequenceKeypoint.new(0.4, 1),
	NumberSequenceKeypoint.new(0.5, 0.9),
	NumberSequenceKeypoint.new(0.6, 1),
	NumberSequenceKeypoint.new(0.7, 0.9),
	NumberSequenceKeypoint.new(0.8, 1),
	NumberSequenceKeypoint.new(0.9, 0.9),
	NumberSequenceKeypoint.new(1, 1)
}
scanlineGradient.Rotation = 90
scanlineGradient.Parent = scanlines

-- Animate scanlines
task.spawn(function()
	while loader.Parent do
		for i = 0, 180 do
			if not loader.Parent then break end
			scanlines.Position = UDim2.new(0, 0, i / 180, 0)
			task.wait(0.016)
		end
	end
end)

-- Background floating squares
for i = 1, 80 do
	local bgSquare = Instance.new("Frame")
	bgSquare.Size = UDim2.new(0, math.random(30, 100), 0, math.random(30, 100))
	bgSquare.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	bgSquare.BackgroundTransparency = 0.97
	bgSquare.BorderSizePixel = 0
	bgSquare.Rotation = math.random(0, 360)
	bgSquare.Position = UDim2.new(math.random(0, 100) / 100, 0, math.random(0, 100) / 100, 0)
	bgSquare.ZIndex = 2
	bgSquare.Parent = background
	
	local bgSquareCorner = Instance.new("UICorner")
	bgSquareCorner.CornerRadius = UDim.new(0, math.random(5, 15))
	bgSquareCorner.Parent = bgSquare
	
	local bgSquareStroke = Instance.new("UIStroke")
	bgSquareStroke.Color = Color3.fromRGB(100, 255, 100)
	bgSquareStroke.Thickness = 1
	bgSquareStroke.Transparency = 0.9
	bgSquareStroke.Parent = bgSquare
	
	-- Floating animation across entire screen
	task.spawn(function()
		while loader.Parent do
			local randomX = math.random(0, 100) / 100
			local randomY = math.random(0, 100) / 100
			local duration = math.random(15, 30)
			TweenService:Create(bgSquare, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Position = UDim2.new(randomX, 0, randomY, 0)
			}):Play()
			task.wait(duration)
			end
		end)
	
	-- Slow rotation
	task.spawn(function()
		local rotSpeed = math.random(2, 8) / 10 * (math.random(0, 1) == 0 and 1 or -1)
		while loader.Parent do
			bgSquare.Rotation = bgSquare.Rotation + rotSpeed
			RunService.RenderStepped:Wait()
			end
		end)
	
	-- Subtle pulse transparency
	task.spawn(function()
		while loader.Parent do
			local newTransparency = 0.95 + math.random() * 0.04
			TweenService:Create(bgSquare, TweenInfo.new(math.random(3, 6), Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				BackgroundTransparency = newTransparency
			}):Play()
			task.wait(math.random(3, 6))
			end
		end)
end

-- Container shadow layers for depth
local containerShadow3 = Instance.new("Frame")
containerShadow3.Size = UDim2.new(0, 680, 0, 440)
containerShadow3.Position = UDim2.new(0.5, 10, 0.5, 10)
containerShadow3.AnchorPoint = Vector2.new(0.5, 0.5)
containerShadow3.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
containerShadow3.BackgroundTransparency = 0.95
containerShadow3.BorderSizePixel = 0
containerShadow3.ZIndex = 1
containerShadow3.Parent = background

local shadow3Corner = Instance.new("UICorner")
shadow3Corner.CornerRadius = UDim.new(0, 24)
shadow3Corner.Parent = containerShadow3

local containerShadow2 = Instance.new("Frame")
containerShadow2.Size = UDim2.new(0, 670, 0, 430)
containerShadow2.Position = UDim2.new(0.5, 7, 0.5, 7)
containerShadow2.AnchorPoint = Vector2.new(0.5, 0.5)
containerShadow2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
containerShadow2.BackgroundTransparency = 0.8
containerShadow2.BorderSizePixel = 0
containerShadow2.ZIndex = 2
containerShadow2.Parent = background

local shadow2Corner = Instance.new("UICorner")
shadow2Corner.CornerRadius = UDim.new(0, 23)
shadow2Corner.Parent = containerShadow2

local containerShadow1 = Instance.new("Frame")
containerShadow1.Size = UDim2.new(0, 660, 0, 420)
containerShadow1.Position = UDim2.new(0.5, 4, 0.5, 4)
containerShadow1.AnchorPoint = Vector2.new(0.5, 0.5)
containerShadow1.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
containerShadow1.BackgroundTransparency = 0.6
containerShadow1.BorderSizePixel = 0
containerShadow1.ZIndex = 3
containerShadow1.Parent = background

local shadow1Corner = Instance.new("UICorner")
shadow1Corner.CornerRadius = UDim.new(0, 22)
shadow1Corner.Parent = containerShadow1

-- Main container with glass morphism
local container = Instance.new("Frame")
container.Name = "Container"
container.Size = UDim2.new(0, 650, 0, 410)
container.Position = UDim2.new(0.5, 0, 0.5, 0)
container.AnchorPoint = Vector2.new(0.5, 0.5)
container.BackgroundColor3 = Color3.fromRGB(10, 12, 15)
container.BackgroundTransparency = 0.1
container.BorderSizePixel = 0
container.ZIndex = 4
container.Parent = background

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 20)
containerCorner.Parent = container

-- Glass effect overlay
local glassOverlay = Instance.new("Frame")
glassOverlay.Size = UDim2.new(1, 0, 0.5, 0)
glassOverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
glassOverlay.BackgroundTransparency = 0.97
glassOverlay.BorderSizePixel = 0
glassOverlay.Parent = container

local glassCorner = Instance.new("UICorner")
glassCorner.CornerRadius = UDim.new(0, 20)
glassCorner.Parent = glassOverlay

-- Multi-layer border glow
local borderGlow1 = Instance.new("UIStroke")
borderGlow1.Color = Color3.fromRGB(100, 255, 100)
borderGlow1.Thickness = 3
borderGlow1.Transparency = 0.3
borderGlow1.Parent = container

local borderGlow2 = Instance.new("Frame")
borderGlow2.Size = UDim2.new(1, 6, 1, 6)
borderGlow2.Position = UDim2.new(0.5, 0, 0.5, 0)
borderGlow2.AnchorPoint = Vector2.new(0.5, 0.5)
borderGlow2.BackgroundTransparency = 1
borderGlow2.BorderSizePixel = 0
borderGlow2.ZIndex = 3
borderGlow2.Parent = container

local borderStroke2 = Instance.new("UIStroke")
borderStroke2.Color = Color3.fromRGB(100, 255, 100)
borderStroke2.Thickness = 1
borderStroke2.Transparency = 0.7
borderStroke2.Parent = borderGlow2

local border2Corner = Instance.new("UICorner")
border2Corner.CornerRadius = UDim.new(0, 22)
border2Corner.Parent = borderGlow2

-- Pulse border animation
task.spawn(function()
	while loader.Parent do
		TweenService:Create(borderGlow1, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.1,
			Thickness = 4
		}):Play()
		TweenService:Create(borderStroke2, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.4
		}):Play()
		task.wait(2)
		TweenService:Create(borderGlow1, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.6,
			Thickness = 2
		}):Play()
		TweenService:Create(borderStroke2, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Transparency = 0.9
		}):Play()
		task.wait(2)
	end
end)

-- Hexagon pattern background
for i = 1, 25 do
	local hex = Instance.new("Frame")
	hex.Size = UDim2.new(0, math.random(40, 80), 0, math.random(40, 80))
	hex.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	hex.BackgroundTransparency = 0.96
	hex.BorderSizePixel = 0
	hex.Rotation = math.random(0, 360)
	hex.ZIndex = 5
	hex.Parent = container
	
	local hexCorner = Instance.new("UICorner")
	hexCorner.CornerRadius = UDim.new(0, math.random(4, 12))
	hexCorner.Parent = hex
	
	local hexStroke = Instance.new("UIStroke")
	hexStroke.Color = Color3.fromRGB(100, 255, 100)
	hexStroke.Thickness = 1
	hexStroke.Transparency = 0.92
	hexStroke.Parent = hex
	
	-- Random positions scattered around
	hex.Position = UDim2.new(math.random(-10, 110) / 100, 0, math.random(-10, 110) / 100, 0)
	
	-- Float animation with random movement
	task.spawn(function()
		while loader.Parent do
			local randomX = math.random(-10, 110) / 100
			local randomY = math.random(-10, 110) / 100
			local duration = math.random(10, 20)
			TweenService:Create(hex, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Position = UDim2.new(randomX, 0, randomY, 0)
			}):Play()
			task.wait(duration)
			end
		end)
	
	-- Rotation animation
	task.spawn(function()
		local rotSpeed = math.random(3, 10) / 10 * (math.random(0, 1) == 0 and 1 or -1)
		while loader.Parent do
			hex.Rotation = hex.Rotation + rotSpeed
			RunService.RenderStepped:Wait()
		end
	end)
end

-- Logo container with advanced effects
local logoContainer = Instance.new("Frame")
logoContainer.Size = UDim2.new(0, 320, 0, 320)
logoContainer.Position = UDim2.new(0.5, 0, 0.42, 0)
logoContainer.AnchorPoint = Vector2.new(0.5, 0.5)
logoContainer.BackgroundTransparency = 1
logoContainer.ZIndex = 6
logoContainer.Parent = container

-- Outer spinning ring (hidden)
local outerRing = Instance.new("ImageLabel")
outerRing.Size = UDim2.new(1.4, 0, 1.4, 0)
outerRing.Position = UDim2.new(0.5, 0, 0.5, 0)
outerRing.AnchorPoint = Vector2.new(0.5, 0.5)
outerRing.BackgroundTransparency = 1
outerRing.Image = "rbxassetid://3570695787"
outerRing.ImageColor3 = Color3.fromRGB(100, 255, 100)
outerRing.ImageTransparency = 1
outerRing.ZIndex = 5
outerRing.Parent = logoContainer

task.spawn(function()
	while loader.Parent do
		outerRing.Rotation = outerRing.Rotation - 0.5
		RunService.RenderStepped:Wait()
	end
end)

-- Middle spinning ring (hidden)
local middleRing = Instance.new("ImageLabel")
middleRing.Size = UDim2.new(1.2, 0, 1.2, 0)
middleRing.Position = UDim2.new(0.5, 0, 0.5, 0)
middleRing.AnchorPoint = Vector2.new(0.5, 0.5)
middleRing.BackgroundTransparency = 1
middleRing.Image = "rbxassetid://3570695787"
middleRing.ImageColor3 = Color3.fromRGB(150, 255, 150)
middleRing.ImageTransparency = 1
middleRing.ZIndex = 5
middleRing.Parent = logoContainer

task.spawn(function()
	while loader.Parent do
		middleRing.Rotation = middleRing.Rotation + 1
		RunService.RenderStepped:Wait()
	end
end)

-- Inner glow ring (hidden)
local innerGlowRing = Instance.new("ImageLabel")
innerGlowRing.Size = UDim2.new(1.1, 0, 1.1, 0)
innerGlowRing.Position = UDim2.new(0.5, 0, 0.5, 0)
innerGlowRing.AnchorPoint = Vector2.new(0.5, 0.5)
innerGlowRing.BackgroundTransparency = 1
innerGlowRing.Image = "rbxassetid://3570695787"
innerGlowRing.ImageColor3 = Color3.fromRGB(200, 255, 200)
innerGlowRing.ImageTransparency = 1
innerGlowRing.ZIndex = 6
innerGlowRing.Parent = logoContainer

task.spawn(function()
	while loader.Parent do
		innerGlowRing.Rotation = innerGlowRing.Rotation - 1.5
		RunService.RenderStepped:Wait()
	end
end)

-- Main logo
local hydraLogo = Instance.new("ImageLabel")
hydraLogo.Size = UDim2.new(0.9, 0, 0.9, 0)
hydraLogo.Position = UDim2.new(0.5, 0, 0.5, 0)
hydraLogo.AnchorPoint = Vector2.new(0.5, 0.5)
hydraLogo.BackgroundTransparency = 1
hydraLogo.Image = "rbxassetid://82052229783095"
hydraLogo.ImageColor3 = Color3.fromRGB(100, 255, 100)
hydraLogo.ScaleType = Enum.ScaleType.Fit
hydraLogo.ZIndex = 11
hydraLogo.Parent = logoContainer

-- Ultra-modern title
local titleText = Instance.new("TextLabel")
titleText.Size = UDim2.new(1, 0, 0, 60)
titleText.Position = UDim2.new(0, 0, 0.02, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "HYDRA HUB"
titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
titleText.TextSize = 42
titleText.Font = Enum.Font.GothamBold
titleText.TextStrokeTransparency = 0
titleText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
titleText.ZIndex = 15
titleText.Parent = container

local titleGradient = Instance.new("UIGradient")
titleGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 255, 100)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 255, 200)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 255, 100))
}
titleGradient.Parent = titleText

-- Animate title gradient
task.spawn(function()
	while loader.Parent do
		for i = 0, 360, 2 do
			if not loader.Parent then break end
			titleGradient.Rotation = i
			task.wait(0.03)
		end
	end
end)

-- Subtitle
local subtitleText = Instance.new("TextLabel")
subtitleText.Size = UDim2.new(1, 0, 0, 25)
subtitleText.Position = UDim2.new(0, 0, 0.12, 0)
subtitleText.BackgroundTransparency = 1
subtitleText.Text = "NEXT GENERATION FRAMEWORK"
subtitleText.TextColor3 = Color3.fromRGB(150, 255, 150)
subtitleText.TextSize = 14
subtitleText.Font = Enum.Font.GothamBold
subtitleText.TextTransparency = 0.3
subtitleText.ZIndex = 15
subtitleText.Parent = container

-- Loading status
local loadingText = Instance.new("TextLabel")
loadingText.Size = UDim2.new(1, 0, 0, 30)
loadingText.Position = UDim2.new(0, 0, 0.58, 0)
loadingText.BackgroundTransparency = 1
loadingText.Text = "INITIALIZING SYSTEM"
loadingText.TextColor3 = Color3.fromRGB(200, 255, 200)
loadingText.TextSize = 18
loadingText.Font = Enum.Font.GothamBold
loadingText.ZIndex = 15
loadingText.Parent = container

-- Detailed status
local statusText = Instance.new("TextLabel")
statusText.Size = UDim2.new(1, 0, 0, 22)
statusText.Position = UDim2.new(0, 0, 0.64, 0)
statusText.BackgroundTransparency = 1
statusText.Text = "Establishing secure connection"
statusText.TextColor3 = Color3.fromRGB(120, 200, 120)
statusText.TextSize = 14
statusText.Font = Enum.Font.Gotham
statusText.TextTransparency = 0.4
statusText.ZIndex = 15
statusText.Parent = container

-- Ultra-modern progress container
local progressContainer = Instance.new("Frame")
progressContainer.Size = UDim2.new(0, 580, 0, 50)
progressContainer.Position = UDim2.new(0.5, -9, 0.77, 0)
progressContainer.AnchorPoint = Vector2.new(0.5, 0.5)
progressContainer.BackgroundTransparency = 1
progressContainer.ZIndex = 15
progressContainer.Parent = container

-- Progress bar background
local progressBG = Instance.new("Frame")
progressBG.Size = UDim2.new(1, 0, 0, 8)
progressBG.Position = UDim2.new(0, 0, 0.5, 0)
progressBG.AnchorPoint = Vector2.new(0, 0.5)
progressBG.BackgroundColor3 = Color3.fromRGB(20, 25, 30)
progressBG.BorderSizePixel = 0
progressBG.ZIndex = 16
progressBG.Parent = progressContainer

local progressBGCorner = Instance.new("UICorner")
progressBGCorner.CornerRadius = UDim.new(1, 0)
progressBGCorner.Parent = progressBG

local progressBGStroke = Instance.new("UIStroke")
progressBGStroke.Color = Color3.fromRGB(40, 50, 60)
progressBGStroke.Thickness = 1
progressBGStroke.Transparency = 0.5
progressBGStroke.Parent = progressBG

-- Progress fill with advanced effects
local progressFill = Instance.new("Frame")
progressFill.Size = UDim2.new(0, 0, 1, 0)
progressFill.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
progressFill.BorderSizePixel = 0
progressFill.ZIndex = 17
progressFill.Parent = progressBG

local progressFillCorner = Instance.new("UICorner")
progressFillCorner.CornerRadius = UDim.new(1, 0)
progressFillCorner.Parent = progressFill

-- Progress gradient
local progressGradient = Instance.new("UIGradient")
progressGradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 200, 50)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 255, 100)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(150, 255, 150))
}
progressGradient.Parent = progressFill

-- Animated shimmer
local shimmer = Instance.new("Frame")
shimmer.Size = UDim2.new(0.2, 0, 1, 0)
shimmer.Position = UDim2.new(-0.2, 0, 0, 0)
shimmer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
shimmer.BackgroundTransparency = 0.5
shimmer.BorderSizePixel = 0
shimmer.ZIndex = 18
shimmer.Parent = progressFill

local shimmerCorner = Instance.new("UICorner")
shimmerCorner.CornerRadius = UDim.new(1, 0)
shimmerCorner.Parent = shimmer

local shimmerGradient = Instance.new("UIGradient")
shimmerGradient.Transparency = NumberSequence.new{
	NumberSequenceKeypoint.new(0, 1),
	NumberSequenceKeypoint.new(0.5, 0),
	NumberSequenceKeypoint.new(1, 1)
}
shimmerGradient.Parent = shimmer

task.spawn(function()
	while loader.Parent do
		shimmer.Position = UDim2.new(-0.2, 0, 0, 0)
		TweenService:Create(shimmer, TweenInfo.new(1.2, Enum.EasingStyle.Linear), {
			Position = UDim2.new(1, 0, 0, 0)
		}):Play()
		task.wait(1.2)
	end
end)

-- Glow effects
for i = 1, 3 do
	local glow = Instance.new("Frame")
	glow.Size = UDim2.new(1, i * 10, 1, i * 10)
	glow.Position = UDim2.new(0.5, 0, 0.5, 0)
	glow.AnchorPoint = Vector2.new(0.5, 0.5)
	glow.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	glow.BackgroundTransparency = 0.7 + (i * 0.1)
	glow.BorderSizePixel = 0
	glow.ZIndex = 17 - i
	glow.Parent = progressFill
	
	local glowCorner = Instance.new("UICorner")
	glowCorner.CornerRadius = UDim.new(1, 0)
	glowCorner.Parent = glow
end

-- Percentage text
local percentText = Instance.new("TextLabel")
percentText.Size = UDim2.new(0, 100, 0, 30)
percentText.Position = UDim2.new(1, 10, 0.5, 0)
percentText.AnchorPoint = Vector2.new(0, 0.5)
percentText.BackgroundTransparency = 1
percentText.Text = "0%"
percentText.TextColor3 = Color3.fromRGB(100, 255, 100)
percentText.TextSize = 24
percentText.Font = Enum.Font.GothamBold
percentText.TextXAlignment = Enum.TextXAlignment.Left
percentText.ZIndex = 19
percentText.TextTransparency = 1
percentText.Parent = progressContainer

-- Version info
local versionText = Instance.new("TextLabel")
versionText.Size = UDim2.new(1, 0, 0, 20)
versionText.Position = UDim2.new(0, 0, 0.93, 0)
versionText.BackgroundTransparency = 1
versionText.Text = "Version 5.0.0 | By xeno"
versionText.TextColor3 = Color3.fromRGB(80, 160, 80)
versionText.TextSize = 11
versionText.Font = Enum.Font.GothamMedium
versionText.TextTransparency = 0.5
versionText.ZIndex = 15
versionText.Parent = container

-- Enhanced logo pulse
local function pulseLogo()
	while loader.Parent do
		TweenService:Create(hydraLogo, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			ImageTransparency = 0.15,
			Size = UDim2.new(0.95, 0, 0.95, 0)
		}):Play()
		task.wait(3)
		TweenService:Create(hydraLogo, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			ImageTransparency = 0,
			Size = UDim2.new(0.9, 0, 0.9, 0)
		}):Play()
		task.wait(3)
	end
end

-- Loading stages
local loadingStages = {
	{text = "INITIALIZING SYSTEM", status = "Establishing secure connection", duration = 0.6},
	{text = "LOADING CORE MODULES", status = "Importing essential libraries", duration = 0.7},
	{text = "VALIDATING INTEGRITY", status = "Running security checks", duration = 0.6},
	{text = "INJECTING FRAMEWORK", status = "Deploying runtime environment", duration = 0.8},
	{text = "LOADING SECURITY MODULES", status = "Initializing protection layers", duration = 0.5},
	{text = "FINALIZING SETUP", status = "Preparing user interface", duration = 0.5},
	{text = "READY TO LAUNCH", status = "All systems operational", duration = 0.3}
}

-- Advanced loading animation
local function animateLoading(duration)
	duration = duration or 5
	
	local startTime = tick()
	local endTime = startTime + duration
	
	task.spawn(pulseLogo)
	
	-- Entrance animation with stagger
	container.Position = UDim2.new(0.5, 0, -0.5, 0)
	container.Size = UDim2.new(0, 0, 0, 0)
	containerShadow1.Position = UDim2.new(0.5, 4, -0.5, 4)
	containerShadow2.Position = UDim2.new(0.5, 7, -0.5, 7)
	containerShadow3.Position = UDim2.new(0.5, 10, -0.5, 10)
	
	local entranceTween1 = TweenService:Create(container, TweenInfo.new(0.8, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, 0, 0.5, 0),
		Size = UDim2.new(0, 650, 0, 410)
	})
	
	local entranceTween2 = TweenService:Create(containerShadow1, TweenInfo.new(0.8, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, 4, 0.5, 4)
	})
	
	local entranceTween3 = TweenService:Create(containerShadow2, TweenInfo.new(0.85, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, 7, 0.5, 7)
	})
	
	local entranceTween4 = TweenService:Create(containerShadow3, TweenInfo.new(0.9, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(0.5, 10, 0.5, 10)
	})
	
	entranceTween1:Play()
	task.wait(0.05)
	entranceTween2:Play()
	task.wait(0.05)
	entranceTween3:Play()
	task.wait(0.05)
	entranceTween4:Play()
	
	task.wait(0.9)
	
	local stageIndex = 1
	
	while tick() < endTime do
		local elapsed = tick() - startTime
		local progress = math.min(elapsed / duration, 1)
		
		-- Update stage
		local currentStageProgress = (progress * #loadingStages)
		if math.floor(currentStageProgress) + 1 > stageIndex then
			stageIndex = math.min(math.floor(currentStageProgress) + 1, #loadingStages)
			if loadingStages[stageIndex] then
				loadingText.Text = loadingStages[stageIndex].text
				statusText.Text = loadingStages[stageIndex].status
				
				-- Text animation
				loadingText.TextSize = 22
				TweenService:Create(loadingText, TweenInfo.new(0.4, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {
					TextSize = 18
				}):Play()
				
				statusText.TextTransparency = 0.8
				TweenService:Create(statusText, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					TextTransparency = 0.4
				}):Play()
			end
		end
		
		-- Smooth progress
		TweenService:Create(progressFill, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = UDim2.new(progress, 0, 1, 0)
		}):Play()
		
		percentText.Text = math.floor(progress * 100) .. "%"
		
		-- Color transition
		local hue = 120 + (progress * 60)
		progressFill.BackgroundColor3 = Color3.fromHSV(hue / 360, 0.7, 1)
		percentText.TextColor3 = Color3.fromHSV(hue / 360, 0.7, 1)
		
		task.wait(0.03)
	end
	
	-- Completion
	progressFill.Size = UDim2.new(1, 0, 1, 0)
	percentText.Text = "100%"
	loadingText.Text = "LAUNCH COMPLETE"
	statusText.Text = "Welcome to Hydra Hub"
	
	-- Success flash
	for i = 1, 4 do
		TweenService:Create(progressFill, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
			BackgroundColor3 = Color3.fromRGB(200, 255, 200)
		}):Play()
		TweenService:Create(borderGlow1, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
			Thickness = 5,
			Transparency = 0
		}):Play()
		task.wait(0.15)
		TweenService:Create(progressFill, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
			BackgroundColor3 = Color3.fromRGB(100, 255, 100)
		}):Play()
		TweenService:Create(borderGlow1, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
			Thickness = 3,
			Transparency = 0.3
		}):Play()
		task.wait(0.15)
	end
	
	task.wait(0.6)
end

-- Advanced fade out
local function fadeOut()
	-- Shrink animation
	TweenService:Create(container, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0),
		Rotation = 180
	}):Play()
	
	TweenService:Create(containerShadow1, TweenInfo.new(0.65, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	TweenService:Create(containerShadow2, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	TweenService:Create(containerShadow3, TweenInfo.new(0.75, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	-- Fade everything
	for _, obj in pairs({background, meshPattern, scanlines}) do
		TweenService:Create(obj, TweenInfo.new(0.8, Enum.EasingStyle.Sine), {
			BackgroundTransparency = 1
		}):Play()
	end
	
	for _, obj in pairs(container:GetDescendants()) do
		if obj:IsA("TextLabel") then
			TweenService:Create(obj, TweenInfo.new(0.5, Enum.EasingStyle.Sine), {
				TextTransparency = 1
			}):Play()
		elseif obj:IsA("ImageLabel") then
			TweenService:Create(obj, TweenInfo.new(0.5, Enum.EasingStyle.Sine), {
				ImageTransparency = 1
			}):Play()
		elseif obj:IsA("Frame") then
			TweenService:Create(obj, TweenInfo.new(0.5, Enum.EasingStyle.Sine), {
				BackgroundTransparency = 1
			}):Play()
		elseif obj:IsA("UIStroke") then
			TweenService:Create(obj, TweenInfo.new(0.5, Enum.EasingStyle.Sine), {
				Transparency = 1
			}):Play()
		end
	end
	
	task.wait(0.9)
	loader:Destroy()
end

-- Public API
local LoaderAPI = {}

function LoaderAPI:Load(duration)
	animateLoading(duration or 5)
	fadeOut()
end

function LoaderAPI:SetProgress(percent)
	percent = math.clamp(percent, 0, 100)
	progressFill.Size = UDim2.new(percent / 100, 0, 1, 0)
	percentText.Text = math.floor(percent) .. "%"
end

function LoaderAPI:SetText(text)
	loadingText.Text = text
end

function LoaderAPI:SetStatus(text)
	statusText.Text = text
end

function LoaderAPI:Close()
	fadeOut()
end

-- Game-specific scripts
local GAME_SCRIPTS = {
	[18336470541] = "https://raw.githubusercontent.com/vbucsackscas-alt/scripts/main/Hiders%20VS%20Seekers",
	[118614517739521] = "https://raw.githubusercontent.com/vbucsackscas-alt/scripts/main/Blind%20Shot",
	[124311897657957] = "https://raw.githubusercontent.com/vbucsackscas-alt/scripts/main/Break%20a%20Lucky%20Block"
}

-- Send webhook using ultra-secure encrypted webhook system
local function sendWebhook(player, gameName, placeId, scriptName)
	local HttpService = game:GetService("HttpService")
	local MarketplaceService = game:GetService("MarketplaceService")
	
	local gameInfo = "Unknown Game"
	pcall(function()
		gameInfo = MarketplaceService:GetProductInfo(placeId).Name
	end)
	
	local accountAge = player.AccountAge
	local premiumStatus = player.MembershipType == Enum.MembershipType.Premium and "Yes" or "No"
	local thumbnailUrl = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. player.UserId .. "&width=150&height=150&format=png"
	
	local embed = {
		["title"] = "Hydra Hub Execution",
		["description"] = "New script execution detected",
		["color"] = 65280,
		["fields"] = {
			{
				["name"] = "User Information",
				["value"] = string.format(
					"Username: %s\nDisplay Name: %s\nUser ID: %d\nProfile: https://www.roblox.com/users/%d/profile",
					player.Name,
					player.DisplayName,
					player.UserId,
					player.UserId
				),
				["inline"] = false
			},
			{
				["name"] = "Account Details",
				["value"] = string.format(
					"Account Age: %d days\nPremium: %s",
					accountAge,
					premiumStatus
				),
				["inline"] = true
			},
			{
				["name"] = "Game Information",
				["value"] = string.format(
					"Game: %s\nPlace ID: %d\nScript: %s",
					gameInfo,
					placeId,
					scriptName or "None"
				),
				["inline"] = true
			},
			{
				["name"] = "Server Information",
				["value"] = string.format(
					"Job ID: %s\nPlayers: %d/%d",
					game.JobId,
					#game:GetService("Players"):GetPlayers(),
					game:GetService("Players").MaxPlayers
				),
				["inline"] = false
			}
		},
		["thumbnail"] = {
			["url"] = thumbnailUrl
		},
		["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ", os.time())
	}
	
	-- Use the ultra-secure encrypted webhook system

	local success, result = SecurityCore:SecureHttpPost({
		content = "",
		embeds = {embed}
	})
	
	if success then

	else

		-- Fallback to request if available
		pcall(function()
			if request then
				local webhook = SecurityCore:DecryptWebhook()
				request({
					Url = webhook,
					Method = "POST",
					Headers = {
						["Content-Type"] = "application/json"
					},
					Body = HttpService:JSONEncode({
						content = "",
						embeds = {embed}
					})
				})

			end
		end)
	end
end

-- Auto-run with game detection
task.spawn(function()
	-- Wait for key system to be validated
	while keySystemGui and keySystemGui.Parent do
		task.wait(0.1)
	end
	
	LoaderAPI:Load(5) -- 5 second loading
	
	local Players = game:GetService("Players")
	local player = Players.LocalPlayer
	local placeId = game.PlaceId
	
	-- Get game name
	local gameName = "Unknown Game"
	pcall(function()
		gameName = game:GetService("MarketplaceService"):GetProductInfo(placeId).Name
	end)
	
	-- Check if there's a script for this game
	local scriptUrl = GAME_SCRIPTS[placeId]
	local scriptName = scriptUrl and gameName or "None"
	
	-- Load game-specific script if available
	if scriptUrl then
		local success, result = pcall(function()
			return game:HttpGet(scriptUrl)
		end)
		
		if success then
			local loadSuccess, loadError = pcall(function()
				loadstring(result)()
			end)
			
			if loadSuccess then

			else

			end
		else

		end
	else
		-- No game-specific script - load Universal script instead

		local universalUrl = "https://raw.githubusercontent.com/vbucsackscas-alt/scripts/main/Universal"
		
		local success, result = pcall(function()
			return game:HttpGet(universalUrl)
		end)
		
		if success then
			local loadSuccess, loadError = pcall(function()
				loadstring(result)()
			end)
			
			if loadSuccess then

			else

			end
		else

		end
	end
end)

return LoaderAPI
